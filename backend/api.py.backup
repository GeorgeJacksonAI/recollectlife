import os
import random

from dotenv import load_dotenv
from flask import Flask, jsonify, request
from flask_cors import CORS

# Load environment variables
load_dotenv()

app = Flask(__name__)
CORS(app)

# Menu Configuration
MENU = {
    "sizes": {
        "1": {"name": "Pequena", "price": 25.00},
        "2": {"name": "M√©dia", "price": 35.00},
        "3": {"name": "Grande", "price": 45.00},
    },
    "flavors": {
        "1": "Margherita",
        "2": "Pepperoni",
        "3": "Quatro Queijos",
        "4": "Calabresa",
        "5": "Portuguesa",
        "6": "Frango com Catupiry",
    },
    "extras": {
        "1": {"name": "Borda Recheada", "price": 5.00},
        "2": {"name": "Bebida", "price": 8.00},
        "3": {"name": "Sobremesa", "price": 12.00},
        "4": {"name": "Nenhum", "price": 0.00},
    },
}

# Conversation Phases
PHASES = {
    "welcome": {
        "message": "Ol√°! Bem-vindo √† Pizzaria Del√≠cia! üçï\nVoc√™ gostaria de fazer um pedido? (sim/n√£o)",
        "next": "size",
    },
    "size": {
        "message": lambda: _format_size_options(),
        "next": "flavor",
        "validator": lambda val: val
        in ["1", "2", "3", "pequena", "m√©dia", "media", "grande", "p", "m", "g"],
    },
    "flavor": {
        "message": lambda: _format_flavor_options(),
        "next": "extras",
        "validator": lambda val: val
        in [str(i) for i in range(1, 7)] + list(MENU["flavors"].values()),
    },
    "extras": {
        "message": lambda: _format_extras_options(),
        "next": "confirmation",
        "validator": lambda val: val
        in ["1", "2", "3", "4", "borda", "bebida", "sobremesa", "nada", "n√£o", "nao"],
    },
    "confirmation": {"message": None, "next": "complete"},  # Generated dynamically
}


def _format_size_options():
    """Format size menu options"""
    lines = ["Qual tamanho de pizza voc√™ deseja?"]
    for key, item in MENU["sizes"].items():
        lines.append(f"{key}. {item['name']} (R$ {item['price']:.2f})")
    return "\n".join(lines)


def _format_flavor_options():
    """Format flavor menu options"""
    lines = ["Qual sabor voc√™ prefere?"]
    for key, flavor in MENU["flavors"].items():
        lines.append(f"{key}. {flavor}")
    return "\n".join(lines)


def _format_extras_options():
    """Format extras menu options"""
    lines = ["Deseja adicionar algo?"]
    for key, item in MENU["extras"].items():
        if item["price"] > 0:
            lines.append(f"{key}. {item['name']} (+R$ {item['price']:.2f})")
        else:
            lines.append(f"{key}. {item['name']}")
    return "\n".join(lines)


class OrderExtractor:
    """Extract and parse order information from message history"""

    @staticmethod
    def extract(messages):
        """Extract order details from conversation messages"""
        order = {
            "size": None,
            "size_price": 0.0,
            "flavor": None,
            "extras": None,
            "extras_price": 0.0,
        }

        for msg in messages:
            if msg.get("role") != "user":
                continue

            content = msg.get("content", "").lower().strip()

            # Extract size
            if not order["size"]:
                order["size"], order["size_price"] = OrderExtractor._parse_size(content)

            # Extract flavor
            if not order["flavor"]:
                order["flavor"] = OrderExtractor._parse_flavor(content)

            # Extract extras
            if not order["extras"]:
                order["extras"], order["extras_price"] = OrderExtractor._parse_extras(
                    content
                )

        return order

    @staticmethod
    def _parse_size(content):
        """Parse pizza size from user input"""
        size_map = {
            "1": "1",
            "pequena": "1",
            "p": "1",
            "2": "2",
            "m√©dia": "2",
            "media": "2",
            "m": "2",
            "3": "3",
            "grande": "3",
            "g": "3",
        }

        for key, normalized in size_map.items():
            if key in content:
                size_data = MENU["sizes"][normalized]
                return size_data["name"], size_data["price"]

        return None, 0.0

    @staticmethod
    def _parse_flavor(content):
        """Parse pizza flavor from user input"""
        flavor_map = {
            "1": "1",
            "margherita": "1",
            "2": "2",
            "pepperoni": "2",
            "3": "3",
            "quatro queijos": "3",
            "4": "4",
            "calabresa": "4",
            "5": "5",
            "portuguesa": "5",
            "6": "6",
            "frango": "6",
            "catupiry": "6",
        }

        for key, normalized in flavor_map.items():
            if key in content:
                return MENU["flavors"][normalized]

        return None

    @staticmethod
    def _parse_extras(content):
        """Parse extras from user input"""
        extras_map = {
            "1": "1",
            "borda": "1",
            "2": "2",
            "bebida": "2",
            "3": "3",
            "sobremesa": "3",
            "4": "4",
            "nada": "4",
            "n√£o": "4",
            "nao": "4",
        }

        for key, normalized in extras_map.items():
            if key in content:
                extra_data = MENU["extras"][normalized]
                return extra_data["name"], extra_data["price"]

        return None, 0.0


def determine_current_phase(messages):
    """Determina em qual fase da conversa estamos baseado no hist√≥rico"""
    if not messages:
        return "welcome"

    # Verifica se a √∫ltima mensagem √© do usu√°rio (aguardando resposta) ou do assistente (aguardando input)
    last_message = messages[-1]
    is_last_user = last_message.get("role") == "user"

    # Conta quantas respostas do usu√°rio j√° foram dadas
    user_count = len([msg for msg in messages if msg.get("role") == "user"])

    # Se a √∫ltima mensagem √© do usu√°rio, determina a pr√≥xima fase baseado em quantas respostas j√° foram dadas
    if is_last_user:
        if user_count == 1:  # Respondeu √† boas-vindas
            return "size"
        elif user_count == 2:  # Respondeu sobre tamanho
            return "flavor"
        elif user_count == 3:  # Respondeu sobre sabor
            return "extras"
        elif user_count == 4:  # Respondeu sobre extras
            return "confirmation"
        elif user_count >= 5:  # Confirmou o pedido
            return "complete"

    # Se a √∫ltima mensagem √© do assistente, ainda estamos na fase anterior
    else:
        last_content = last_message.get("content", "").lower()
        if "fazer um pedido" in last_content or "bem-vindo" in last_content:
            return "welcome"
        elif "tamanho" in last_content:
            return "size"
        elif "sabor" in last_content:
            return "flavor"
        elif "adicionar" in last_content or "borda" in last_content:
            return "extras"
        elif "confirmar" in last_content or "pedido est√° correto" in last_content:
            return "confirmation"
        elif "pedido confirmado" in last_content:
            return "complete"

    return "welcome"


def generate_response(messages, current_phase, order):
    """Gera resposta baseada na fase atual"""

    if current_phase == "welcome":
        user_last_msg = messages[-1].get("content", "").lower() if messages else ""
        if any(word in user_last_msg for word in ["sim", "yes", "s", "quero", "fazer"]):
            return PIZZA_PHASES["size"]["question"]
        else:
            return "Tudo bem! Se mudar de ideia, estarei aqui. Tenha um √≥timo dia! üçï"

    elif current_phase == "size":
        # Valida se o usu√°rio escolheu um tamanho v√°lido
        user_last_msg = messages[-1].get("content", "").lower() if messages else ""
        if any(word in user_last_msg for word in PIZZA_PHASES["size"]["options"]):
            return PIZZA_PHASES["flavor"]["question"]
        else:
            return (
                "Por favor, escolha uma op√ß√£o v√°lida (1, 2 ou 3):\n"
                + PIZZA_PHASES["size"]["question"]
            )

    elif current_phase == "flavor":
        user_last_msg = messages[-1].get("content", "").lower() if messages else ""
        if any(word in user_last_msg for word in PIZZA_PHASES["flavor"]["options"]):
            return PIZZA_PHASES["extras"]["question"]
        else:
            return (
                "Por favor, escolha um sabor v√°lido (1 a 6):\n"
                + PIZZA_PHASES["flavor"]["question"]
            )

    elif current_phase == "extras":
        user_last_msg = messages[-1].get("content", "").lower() if messages else ""
        if any(word in user_last_msg for word in PIZZA_PHASES["extras"]["options"]):
            # Gera confirma√ß√£o
            order = extract_order_info(messages)
            confirmation = f"""Perfeito! Vamos confirmar seu pedido:
            
üçï Pizza {order.get('tamanho', 'N/A')} - {order.get('sabor', 'N/A')}
‚ûï Extras: {order.get('extras', 'Nenhum')}

O pedido est√° correto? (sim/n√£o)"""
            return confirmation
        else:
            return (
                "Por favor, escolha uma op√ß√£o v√°lida (1 a 4):\n"
                + PIZZA_PHASES["extras"]["question"]
            )

    elif current_phase == "confirmation":
        user_last_msg = messages[-1].get("content", "").lower() if messages else ""
        if any(
            word in user_last_msg
            for word in ["sim", "yes", "s", "correto", "confirmar"]
        ):
            order = extract_order_info(messages)
            # Gera n√∫mero de pedido aleat√≥rio
            order_number = random.randint(1000, 9999)
            return f"""Pedido confirmado! ‚úÖ

üì¶ N√∫mero do pedido: #{order_number}
üçï Pizza {order.get('tamanho', 'N/A')} - {order.get('sabor', 'N/A')}
‚ûï Extras: {order.get('extras', 'Nenhum')}

Seu pedido ser√° preparado e entregue em aproximadamente 30-40 minutos.
Obrigado por escolher a Pizzaria Del√≠cia! üçï"""
        else:
            return (
                "Entendi. Vamos recome√ßar o pedido?\n"
                + PIZZA_PHASES["size"]["question"]
            )

    else:
        return "Obrigado! Se precisar de mais alguma coisa, estarei aqui! üçï"


@app.route("/api/chat", methods=["POST"])
def chat():
    try:
        data = request.json

        # Valida se as mensagens foram enviadas
        if not data:
            return jsonify({"error": "Dados n√£o fornecidos"}), 400

        # Aceita tanto 'message' (compatibilidade) quanto 'messages' (hist√≥rico completo)
        messages = data.get("messages", [])

        if not messages:
            # Fallback para formato antigo
            if "message" in data:
                user_message = data["message"].strip()
                if not user_message:
                    return jsonify({"error": "Mensagem vazia"}), 400
                messages = [
                    {
                        "role": "assistant",
                        "content": PIZZA_PHASES["welcome"]["question"],
                    },
                    {"role": "user", "content": user_message},
                ]
            else:
                return jsonify({"error": "Mensagens n√£o fornecidas"}), 400

        # Determina a fase atual da conversa
        current_phase = determine_current_phase(messages)

        # Extrai informa√ß√µes do pedido
        order = extract_order_info(messages)

        # Gera resposta baseada na fase
        response_text = generate_response(messages, current_phase, order)

        return jsonify({"response": response_text, "phase": current_phase}), 200

    except Exception as e:
        print(f"Erro ao processar mensagem: {e}")
        import traceback

        traceback.print_exc()
        return jsonify({"error": f"Erro ao processar mensagem: {str(e)}"}), 500


@app.route("/health", methods=["GET"])
def health():
    return jsonify({"status": "ok"}), 200


if __name__ == "__main__":
    print("üöÄ Servidor Flask rodando em http://localhost:5000")
    print("üì° Endpoint dispon√≠vel: POST /api/chat")
    app.run(debug=True, port=5000)
